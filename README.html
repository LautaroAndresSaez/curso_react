<html>
      <head>
        <meta charset="UTF-8">
        <title>README.md</title>
      </head>
      <body>
        <h1 id="1-fundamentos-de-las-herramientas-de-desarrollo-orange_book-">1-Fundamentos de las herramientas de desarrollo :orange_book:</h1>
<p>Veremos herramientas utiles para el desarrollo con <strong>REACT</strong> como <strong>NPM</strong>, <strong>BABEL</strong>, <strong>WEBPACK</strong> aunque tambien
se utilizaran </p>
<h2 id="entorno-de-desarrollo-de-react-js">Entorno de desarrollo de REACT JS</h2>
<p>Se puede implementar <strong>REACT</strong> utilizando la libreria sin compilar pero lo mas recomendado es utilizar
<strong>JSX</strong> el cual es un lenjuage compilado.
Para la implementacion de <strong>REACT</strong> se utilizara el modulo <em>create-react-app</em>.</p>
<h2 id="explicacion-de-npm-webpack-y-babel">Explicacion de NPM, Webpack y babel</h2>
<p><strong>NPM</strong>: Es un gestor de modulos de JS.</p>
<p><strong>BABEL</strong>: Es un traductor de codigo JS con estandares nuevos, lo que permite que el projecto sea
utilizable en cualquier navegador, aunque este no soporte los ultimos estandares del <strong>ecmascript</strong>.</p>
<p><strong>WEBPACK</strong>: Permite ulizar modulos para reutilizar codigos, es muy util utilizarlo junto con <strong>BABEL</strong>.</p>
<h2 id="chrome-devtools">Chrome DevTools</h2>
<p>Para abrir las <strong>DevTools</strong> se utiliza <em>ctrl+shift+i</em>.</p>
<p>Las <strong>DevTools</strong> posee  una <em>consola</em> la cual permite una interaccion
entre el programa y el navegador.</p>
<h2 id="creando-stack-con-react">Creando Stack con REACT</h2>
<p>Para crear una app de <strong>REACT</strong> utilizamos el comando <strong>CREATE-REACT-APP <em>nombre app</em></strong>, este comando puede ser instalado con <strong>NPM</strong>.</p>
<h2 id="comandos-utiles">Comandos utiles</h2>
<ul>
<li><strong>NPM START</strong>: Ejecuta la aplicacion en un servidor local.</li>
<li><strong>NPM RUN</strong>: </li>
</ul>
<h2 id="estructura-del-proyecto">Estructura del proyecto</h2>
<p>Dentro de la carpeta <strong>public</strong> se encuentra el <strong>INDEX.html</strong> en el cual se puede encontrar un <em>div</em> de clase <em>root</em> que en donde se generara nuestra aplicacion. 
El archivo <strong>manifest.json</strong> se encuentra las cosas necesarias para realizar una <strong>PWA</strong>.</p>
<p>Dentro de la carpeta <strong>src</strong> se encuentran todos los archivos de la aplicacion
, en el <strong>Index.js</strong> se encuentra importa el modulo <em>serviceWorker</em> junto con el archivo <strong>serviceWorker.js</strong> se utiliza
para generar una <strong>PWA</strong>.</p>
<h1 id="2-introduccion-react-core">2-Introduccion REACT CORE</h1>
<p>Esta seccion permite comprender el entorno de <strong>REACT</strong>, y todo su entorno como <strong>JSX</strong> y las <strong>expresiones</strong> las cuales permiten generar codigo <em>html</em> de forma de reutilizar codigo. 
Junto con la aplicacion de codigo de <strong>CSS</strong> para mejor las paginas web.</p>
<p>Los temas vistos en esta seccion son:</p>
<ol>
<li>Introduccion a JSX</li>
<li>Componentes</li>
<li>JSX en profundidad</li>
<li>Ecmascript 6</li>
<li>Manejo de Eventos</li>
<li>Extras</li>
</ol>
<h2 id="introduccion-a-jsx">Introduccion a JSX</h2>
<p><strong>JSX</strong> es una combinacion entre <strong>JS</strong> y <strong>HTML</strong> la cual permite indexar directamente <strong>HTML</strong> en codigo <strong>JS</strong>.</p>
<h3 id="creacion-de-elementos-e-insercion-en-el-dom">Creacion de elementos e insercion en el DOM</h3>
<p>Utilizar <strong>REACT</strong> debo importar el modulo <strong><em>React</em></strong> y <strong><em>ReactDOM</em></strong>.</p>
<p><img src="./images/0001.png?raw=true" alt="insercion" title="Title"></p>
<h3 id="expresiones">Expresiones</h3>
<p>Para insertar una expresion en <strong>JSX</strong>, utilizando llaves, dentro de ellos puedo colocar cualquier expresion valida de <strong>JS</strong>.</p>
<p><img src="./images/0002.png?raw=true" alt="insercion" title="Title"></p>
<h2 id="componentes">Componentes</h2>
<p>Los componentes permiten la reutilizacion de codigo
. Existen 2 grandes grupos de componentes los <strong>FUNCIONALES</strong> y 
<strong>BASADOS EN CLASES</strong>. Los mas recomendables para 
utilizar son los componentes <strong>FUNCIONALES</strong> ya que necesitan
menor cantidad de lineas de codigo gracias a los <strong>HOOKS</strong>.</p>
<h3 id="funcionales">Funcionales</h3>
<p>Son funciones que retornan una unica etiqueta de <strong>HTML</strong>. Para 
llamar un componente un funcional se debe utilizar la nomenclatura clasica de <strong>HTML</strong>.</p>
<p><img src="./images/0003.png?raw=true" alt="insercion" title="Title"></p>
<h3 id="props">Props</h3>
<p>Las <strong>props</strong> son variables de entrada de los componentes,
los componentes que se le pasan a un <strong>props</strong> se deben utilizar
llaves aunque para los datos de tipo <strong>String</strong> son opcionales.</p>
<p><img src="./images/0004.png?raw=true" alt="insercion" title="Title"></p>
<h3 id="clases">Clases</h3>
<p>Son clases que extienden de <strong>React.Component</strong> y debe implementar 
un metodo <strong>render</strong> el cual renderiza el componente.</p>
<p>Los componentes basados en clases soportan una actualizacion dinamica, utilizando una variable de clase <strong>state</strong> y para actulizar el componente se
utiliza el metodo <em>setState</em>. </p>
<p><strong>ACLARACION</strong>: Para los metodos que utilicen <strong>this</strong> es recomendable utilizar
el metodo <strong>bind( this )</strong> para todos los metodos que lo requieran.
Es recomendable utilizar inicializadores de propiedades.</p>
<h4 id="inicializadores-de-propiedades">Inicializadores de Propiedades</h4>
<p>Se crea un atributo fuera del constructor y permite presindir del mismo
ya que la unica llamada necesaria es la del constructor del padre.</p>
<p><img src="./Images/00005.png" alt="Inicializadores de propiedades"></p>
<h2 id="factorizacion-de-componentes">Factorizacion de componentes</h2>
<p>Es muy recomendable tener los componentes separados en diferentes carpetas, para lograr tener el codigo mucho mas ordenado.</p>
<h2 id="jsx-en-profundidad">JSX en profundidad</h2>
<p>Los componentes deben comenzar con mayuscula, ya que sino <strong>Babel</strong> no tomara como valido.</p>
<p>Para agregar una clase a una etiqueta se utiliza <strong>className</strong>.</p>
<p><strong>JSX</strong> permite declarar modulos de componentes, es decir, es posible 
crear objetos <strong>JSON</strong> donde cada atributo sea un componente.</p>
<h2 id="css-en-react">CSS en React</h2>
<p>Para indexar codigo <strong>CSS</strong> debo colocar el atributo <strong>style</strong> y pasar
como argumento un objeto que contenga las propiedades.</p>
<p><img src="./Images/0006.png" alt="Inicializadores de propiedades"></p>
<p>Si el estilo posee un gion medio (-) se utiliza la notacion <strong>camelCase</strong>.
<strong>JSX</strong> permite la implementacion de operadores ternarios dentro de los objetos, lo cual hace mucho mas sencilla la implementacion
de estilos segun los estados.</p>
<p><img src="./Images/00007.png" alt="Inicializadores de propiedades"></p>
<h3 id="css-utilizando-clases">CSS utilizando clases</h3>
<p>Es recomendable utilizar dentro de cada carpeta del componente
sus estilos, lo que permite tener componentes aun mas modularizados.
<strong>JSX</strong> permite importar archivos <strong>CSS</strong> directamente, esto sucede gracias
al paquete de <strong>WebPack</strong>.</p>
<p><img src="./Images/0008.png" alt="Inicializadores de propiedades"></p>
<h3 id="sistemas-de-modulos">Sistemas de Modulos</h3>
<p>Cuando se desea utilizar un sistema de modulos de <strong>CSS</strong> el arvhivo debe ser nombrado de la siguiente forma:</p>
<p><strong><em>nombre</em>.modules.css</strong></p>
<h2 id="ecmascript-6">Ecmascript 6</h2>
<h3 id="object-assing-1-">Object.assing() :+1:</h3>
<p>Este metodo sirve para combinar objetos, pero si existe una coincidencia entre los atributos de los objetos
estas seran sobreescritas por la ultima encontrada.
La solucion de este problema puede es utilizar el metodo <strong>Assing</strong> sobre los atributos que se pisan creando un objetonuevo dentro de ese atributo.</p>
<h3 id="operador-spread-">Operador Spread [ <em>...</em> ]</h3>
<p>Cuando poseo objetos dentro de objetos se utiliza el operador
<strong>Spread</strong>. El cual remplaza al metodo <strong>Assing</strong> con una sintaxis mucho mas amigable.</p>
<p><img src="./Images/0009.png" alt="Inicializadores de propiedades"></p>
<p>EL operador <strong>spread</strong> sirve para concatenar <strong>arrays</strong> de una forma muy util</p>
<h4 id="pasando-props-con-spread">Pasando props con Spread</h4>
<p>Podemos utilizar el operador <strong>Spread</strong> para pasar parametros a los componetes de la forma:</p>
<p><img src="./Images/0011.png" alt="Inicializadores de propiedades"></p>
<h3 id="mutacion-de-componenetes-utilizando-funciones">Mutacion de componenetes utilizando funciones</h3>
<p>Debido a que el metodo <strong>setState</strong> es asincrono es muy util utilizar una funcion de callback dentro del
metodo.</p>
<p><img src="./Images/0010.png" alt="Inicializadores de propiedades"></p>
<h2 id="manejo-de-eventos">Manejo de eventos</h2>
<h3 id="eventos-de-mouse">Eventos de Mouse</h3>
<p>Exiten varios tipos de eventos de <em>Mouse</em> utiles cuando se desea utilizar <strong>REACT</strong>,
algunos de ellos son:</p>
<ul>
<li>onClick</li>
<li>onMouseDown</li>
<li>onMouseUp</li>
<li>onMouseMove</li>
</ul>
<p>Para mayor informacion se recomienda ir a la pagina oficial de <strong>REACT</strong>.</p>
<h3 id="eventos-tipo-input">Eventos tipo Input</h3>
<p>Las etiquetas de <strong>Input</strong> poseen eventos muy utiles como:</p>
<ul>
<li>onChange</li>
<li>onPaste</li>
<li>onCopy</li>
</ul>
<p>Los cuales ayudan a manejar la web de forma dinamica.</p>
<h3 id="crear-eventos-personalizados-en-react">Crear eventos personalizados en REACT</h3>
<p><strong>REACT</strong> permite crear eventos personalizados, lo que hasta ahora lo hemos visto como <strong>props</strong> aunque ahora podremos pasar 
informacion de un componente padre a un componente hijo y viceversa.</p>
<p>En el componenete padre utilizamos:</p>
<p><img src="./Images/0012.png" alt="Inicializadores de propiedades"></p>
<p>Mientras que en el componente hijo se utiliza</p>
<p><img src="./Images/0013.png" alt="Inicializadores de propiedades"></p>
<h2 id="extras">Extras</h2>
<h3 id="inyectando-html-en-componentes">Inyectando HTML en componentes</h3>
<p>Si bien esta practica esta desaconsejada, en algunas ocasiones puede ser util
esto se logra utilizando el atributo <strong><em>dangerouslySetInnerHTML</em></strong> y pasandole un <strong>JSON</strong> con el atributo <strong>__html</strong>.</p>
<h3 id="prop-especial-childen">Prop especial childen</h3>
<p>Si se desea utilizar etiquetas dentro de elementos componentes se puede utilizar la <strong>prop</strong> <strong>children</strong>, para ello
es necesatrio abrir y cerrar la etiqueta del componente.</p>
<p><img src="./Images/0014.png" alt="Inicializadores de propiedades"></p>
<h3 id="destructuracion-avanzada">Destructuracion avanzada</h3>
<p>La destructuracion nos permite que el codigo sea mucho mas legible, y menos confuso.</p>
<p><img src="./Images/0015.png" alt="Inicializadores de propiedades"></p>
<p>Es valido utilizar valores por defecto y destructuracion concatenada</p>
<p><img src="./Images/0016.png" alt="Inicializadores de propiedades"></p>
<h3 id="elementos-sin-etiquetas-con-fragment">Elementos sin etiquetas con <em>fragment</em></h3>
<p>El <strong>fragment</strong> es una etiqueta de <strong>REACT</strong> que permite omitir la envoltura de etiquetas en los componentes,
las formas de utilizar esta etiqueta son:</p>
<p><img src="./Images/0017.png" alt="Inicializadores de propiedades"></p>
<h3 id="portals">Portals</h3>
<p>Los portals permiten renderizar etiquetas en otra etiqueta que no se <strong>root</strong>, lo cual es muy
util a la hora de hacer modals.</p>
<p><img src="./Images/0018.png" alt="Inicializadores de propiedades"></p>
<p>Para utilizar el modal debo llamar el componenete en mi <strong>App.js</strong>.</p>
<p><strong>ACLARACION: SE DEBE CREAR UN DIV CON EL ID <em>modal-root</em>, pues</strong>
<strong>REACT no es magico.</strong></p>
<h3 id="control-de-datos-de-entrada">Control de datos de entrada</h3>
<p>Para utilizar el control de datos es necesario utilizar el modulo <strong>PropTypes</strong> de <strong>JS</strong>, el cual se puede instalar con
<strong>NPM</strong> mediante el comando <strong>npm i prop-types</strong>.</p>
<p>Cuando se desea utilizar el control de datos, se debe implementar de la forma:</p>
<p><img src="./Images/0019.png" alt="Inicializadores de propiedades"></p>
<p>Donde en este caso <strong>Profile</strong> es un componente basado en clases, pero la nomenclatura para componentes <strong>funcionales</strong> es la misma.</p>
<h3 id="datos-de-entrada-por-defecto">Datos de entrada por defecto</h3>
<p>Como es posible la comprobacion de datos, tambien se puede definir valores por defecto a las <strong>props</strong>,
implementacion es identica a la de las <strong>proptypes</strong>, con la unica diferencia que debo llamar el atributo
<strong>defaultProps</strong></p>
<h1 id="3-iterando-listas">3-Iterando Listas</h1>
<p>En este apartado se tratara el tema de <strong>iteradores</strong>, ya sea sobre <strong>arrays</strong>, <strong>JSON arrays</strong> y <strong>JSON</strong>.</p>
<ol>
<li>Iteracion de Arrays</li>
<li>Iterando propiedades de JSON</li>
<li>Propiedad KEY</li>
<li>Informacion de los datos iterados</li>
</ol>
<h2 id="iteracion-de-arrays">Iteracion de Arrays</h2>
<p>Para iterar un array en <strong>REACT</strong> se hace uso del metodo <strong><em>map</em></strong> que poseen los arrays, y junto con la notacion
de <strong>JSX</strong> se retorna un elemento <strong>HTML</strong>.</p>
<p><img src="./Images/0020.png" alt="Inicializadores de propiedades"></p>
<p><strong>ACLARACION: los arrays pueden contener objetos tales como los JSON.</strong></p>
<h2 id="iternado-propiedades-de-json">Iternado propiedades de JSON</h2>
<p>Para iterar las <strong>keys</strong> de un objeto <strong>JSON</strong> se debo implementar de la siguiente forma:</p>
<p><img src="./Images/0021.png" alt="Inicializadores de propiedades"></p>
<h2 id="propiedad-key">Propiedad KEY</h2>
<p>Al recorrer <strong>Array</strong> es necesario definir un atributo <strong>key</strong> a las etiqueas, es muy recomendable utilizar el atributo
<strong>ID</strong> que viene de la base de datos. </p>
<p>El beneficio de esta implementacion es que permite que el navegador renderice aquellos elementos que han mutado.</p>
<h2 id="informacion-de-los-datos-iterados">Informacion de los datos iterados</h2>
<p>Para pasar informacion del dato iterado se puede utilizar el metodo <strong>bind</strong> y pasarle como parametros <strong>this</strong> y <strong>DATO</strong>.</p>
<p><img src="./Images/0022.png" alt="Inicializadores de propiedades"></p>
<h1 id="4-entendiendo-las-refs">4- Entendiendo las Refs</h1>
<p>Las <strong>REFS</strong> son referencias en el <strong>DOM</strong>, nos permiten utilizar metodos de las etiquetas <strong>HTML</strong> tales como
<strong>FOCUS</strong> o <strong>BLUR</strong>.</p>
<p><img src="./Images/0023.png" alt="Inicializadores de propiedades"></p>
<p>Para implementar accesos al <strong>DOM</strong> existe la opcion de utilizar las <strong>REFS</strong> con el metodo:</p>
<blockquote>
<p>this.refs_name.current</p>
</blockquote>
<h2 id="envio-de-la-prop-especial-ref-con-forwardref">Envio de la prop especial ref con <em>forwardref</em></h2>
<p>Con el metodo <strong>forwardref</strong> puedo enviar una <strong>REF</strong> de un componente padre a un componente hijo, con la salvedad de que el hijo debe 
ser funcional.</p>
<p><img src="./Images/0024.png" alt="Inicializadores de propiedades"></p>
<h1 id="5-formularios">5- Formularios</h1>
<p>Existen 2 formas de obtener informacion de <strong>inputs</strong> en <strong>REACT</strong>, las cuales son:</p>
<h2 id="inputs-no-controlados">Inputs no controlados</h2>
<p>1- Utilizando <strong>REFS</strong> es los inputs
2- Utilizando una etiqueta <strong>form</strong> y en el metodo que llame la accion <strong>onSubmit</strong> usar el <strong>event</strong> 
para acceder a los diferentes inputs.</p>
<p><img src="./Images/0025.png" alt="Inicializadores de propiedades"></p>
<h3 id="ventajas">Ventajas</h3>
<ul>
<li>Codigo facil de crear</li>
<li>Muy similar a codigo <strong>HTML</strong></li>
</ul>
<h3 id="desventajas">Desventajas</h3>
<ul>
<li>no permite la validacion mientras la informacion cambia</li>
</ul>
<h2 id="inputs-controlados">Inputs controlados</h2>
<p>Los inputs controlados se pueden implementar mediante:</p>
<p>El uso de la variable <strong>state</strong>.</p>
<p><img src="./Images/0026.png" alt="Inicializadores de propiedades"></p>
<h2 id="etiquetas-de-formularios">Etiquetas de Formularios</h2>
<h3 id="select">Select</h3>
<p>Esta etiqueta permite que la seleccion de una lista de opciones, para leer el valor obtenido
es recomendable utilizar inputs controlados.</p>
<h3 id="checkbox">Checkbox</h3>
<p>Permite seleccionar una propiedad, por ejemplo, si el usuario desea recibir emails. Se utiliza igual que cualquier input controlado.</p>
<h1 id="6-debugging">6- Debugging</h1>
<h2 id="chrome-dev-tools">Chrome Dev Tools</h2>
<p>Chrome posse una extension de <strong>REACT</strong> la cual hace mas sencillo el debugging de las webs con este framework.</p>
<p>Esta herramienta incluye 2 nuevas ventanas a la herramienta de inspeccion de chrome, las cuales son <strong>components</strong> y <strong>profile</strong>.</p>
<h3 id="components">Components</h3>
<p>Muestra los componentes incluidos en la web, muy parecido a la inspeccion de elementos, pero separado por componentes.</p>
<h3 id="profiler">Profiler</h3>
<p>Permite crear perfiles de lo que sucede en un determinado tiempo del componente, analizando el tiempo que tarda el componente en actulizarce.</p>
<h2 id="manejo-y-limite-de-errores-dentro-de-componentes">Manejo y limite de errores dentro de componentes</h2>
<p><strong>REACT</strong> permite utilizar un metodo llamador <strong>componentDidCatch</strong> el cual se puede implementar en cualquier componenete y 
permite mostrar una vista alternativa cuando sucede un error. Es recomendable
implementar una clase que maneje lo errores y que renderice a los elementos hijos cuando todo anda bien y cuando no, renderice una
vista personalizada.</p>
<p>Este metodo puede tener dos parametros de entrada:
1- <strong>error</strong>: contiene el tipo de error.
2- <strong>errorInfo</strong>: contiene la descripcion del error.</p>
<h1 id="7-solicitudes-http">7- Solicitudes HTTP</h1>
<p>Si bien <strong>REACT</strong> no posee modulos propios para las solicitudes <strong>HTTP</strong> es posible utilizar distintos metodos para
la implementacion de dichas peticiones.</p>
<h2 id="peticiones-fetch">Peticiones Fetch</h2>
<p>Una forma de realizar peticiones <strong>HTTP</strong> es utilizar la funcion <strong>fetch</strong>, la cual proviene de JS vanilla, debemos recordar que la misma
devuelve una promesa, por lo tanto se debe utilizar el metodo <strong>then</strong> para obtener los resultados.</p>
<p><img src="./Images/0027.png" alt="Inicializadores de propiedades"></p>
<h2 id="peticiones-con-axios">Peticiones con Axios</h2>
<p>Axios es una libreria de <strong>JS</strong> que permite dar soporte a navegador antiguos.</p>
<p><img src="./Images/0028.png" alt="Inicializadores de propiedades"></p>
<h2 id="async-y-await-para-solicitudes-htpp">Async y Await para solicitudes HTPP</h2>
<p>Las sentencias <strong>async</strong> y <strong>await</strong> permiten hacer que el codigo asincrono parezca codigo sincrono, esperando
una respuesta del servidor antes de seguir ejecutar ciertas lineas de codigo.</p>
<p><img src="./Images/0029.png" alt="Inicializadores de propiedades"></p>
<h1 id="8-metodos-de-los-ciclos-de-vida-de-los-componentes">8- Metodos de los ciclos de vida de los componentes</h1>
<p>Los metodos de ciclos de vida son solo validos en componentes basados en clases, para componentes
funcionales existen los <strong>HOOKS</strong>, los cuales se veran en otra seccion.</p>
<p><img src="./Images/0030.png" alt="Inicializadores de propiedades"></p>
<h2 id="constructor">Constructor</h2>
<p>Es el primer metodoen ejecutarse, y sirve para preestablecer valores del estado o para pasar el contexto adecuado
a un metodo, utilizando <strong>bind</strong>, o crear las <strong>refs</strong> necesarias.</p>
<h2 id="render">Render</h2>
<p>Es el encargado de renderizar el componente, y es el unico metodo obligatorio que debemos implementar <strong>siempre</strong>, como lo hemos venido haciendo
a lo largo de este curso.</p>
<h2 id="componentdidmount">componentDidMount</h2>
<p>Se ejecuta luego del render, durante el montaje, y es un excelente lugar para realizar solicitudes HTTP</p>
<h2 id="componentdidupdate">componentDidUpdate</h2>
<p>Es un metodo identico al anterior solo que se ejecuta cada vez que sucede una actualizacion, es decir,
cuando se ejecuta un cambio en el <strong>state</strong> del componente, un cambio en las <strong>props</strong> recibidas
o cuando se fuerza la actulizacion del componenete.</p>
<p>Este metodo es util para realizar solicitudes <strong>HTTP</strong> que dependan de alguna <strong>prop</strong>.</p>
<p><strong>DATO: el metodo puede recibir como primer dato las props previas y como segundo dato las nuevas props, lo cual</strong>
<strong>es util para ahorrar datos a la hora de hacer solicitudes HTTP.</strong></p>
<h2 id="getsnapshotbeforeupdate">getSnapshotBeforeUpdate</h2>
<p>Se ejecuta inmediatamente luego del render y antes de actualizar el <strong>DOM</strong>, lo cual nos permite capturar
datos del <strong>DOM</strong> antes de su actualizacion.</p>
<p>El valor que retorna este metodo llega al metodo componentDidUpdate.</p>
<h2 id="getdeliverystatefromprops">getDeliveryStateFromProps</h2>
<p>Es muy poco frecuente la implementacion de este metodo <strong>estatico</strong>, por lo cual no se puede acceder a propiedades del componente
, su utilidad principal es actualizar al <strong>props</strong> de forma dinamica, como entrada posee <strong>nextProp</strong> y el <strong>prevState</strong>.</p>
<p>Este metodo debe retornar un <strong>JSON</strong> el cual se mezclara con el <strong>state</strong> actual.</p>
<h2 id="shouldcomponentupdate">shouldComponentUpdate</h2>
<p>Se ejecuta antes del render y decide si el render se realizara o no. Este metodo debe retornar si o si un valor booleano, ya que
sino <strong>REACT</strong> marcara un error.</p>
<p>Es usual utilizar este metodo para optimizar el rendimiendo de la web app, renderizando solo los elementos que cambian entre 
las diferentes actulizaciones.</p>
<h2 id="purecomponent">PureComponent</h2>
<p>Es una clase que permite realizar lo mismo que <strong>shouldComponentUpdate</strong>, este es util para implementar en componentes
que se vayan a utilizar para iteraciones.</p>
<p><strong>ACLARACION: toda clase que herede de PureComponent solo realizara comparariones de propiedades de 1er nivel, si alguna propiedad es un JSON que</strong>
<strong>tiene otro JSON indexado la actualizacion sera erronea.</strong></p>
<h2 id="componentwillunmount">componentWillUnmount</h2>
<p>Es el unico metodo se aplica cuando el componente es destruido. Y se utiliza para limpiar <strong>timers</strong>, <strong>listeners</strong> o <strong>metodos del padre</strong>.</p>
<h1 id="9-composicion-y-comunicacion-entre-componentes">9- Composicion y comunicacion entre componentes</h1>
<p>En este apartado se vera en profundidad las diferentes formas de comunicacion entre componentes, comenzando desde las mas sencillas
como <strong>Padre-Hijo</strong> e <strong>Hijo-Padre</strong> hasta algunas mas complejas como comunicaciones entre cualquier componente sin import su gerarquia.</p>
<h2 id="comunicacion-padre-hijo">Comunicacion Padre - Hijo</h2>
<p>Es posible utilizar los metodos declarados en <strong>Hijo</strong> ingresano una <strong>ref</strong> desde el componente <strong>padre</strong> al componente <strong>Hijo</strong>, lo cual
tambien nos permite hacer mutaciones el el <strong>Hijo</strong></p>
<p><img src="./Images/0031.png" alt="Inicializadores de propiedades"></p>
<h2 id="comunicacion-hijo-padre">Comunicacion Hijo - Padre</h2>
<p>Debido a como es el manejo del <strong>DOM</strong> y los eventos es posible realizar una comunicacion <strong>Hijo</strong> <strong>Padre</strong> utilizando el mismo evento
en ambos y para mandar informacion al evento, al cual llamaremos <strong>e</strong> se le agrega un atributo el cual subira en la jerarquia de eventos.</p>
<p><strong>ACLARACION: gracias a esto es posible realizar comunicacion ñieto abuelo, o desde componentes inferiores a componentes de mayor jerarquia.</strong></p>
<p>Esta practica es desaconsejable ya que existen dos flujos dentro de la aplicacion.</p>
<h2 id="comunicacion-hermanos">Comunicacion Hermanos</h2>
<p>Para comunicar hermanos se debe implementar una <strong>prop</strong> que sea afectada por uno de ellos y el otro pueda observarla, es decir,
cuando yo haga click en un boton dicho evento debe afectar la <strong>prop</strong> que recibe alguno de sus hermanos.</p>
<h2 id="observar-pattern">Observar Pattern</h2>
<p>Para lograr comunicacion entre cualquierar componente a cualquier componente, sin importar cual sea su orden gerarquico,
para ello se debe utilizar alguna libreria que permita dicha implementacion, la mas conocida a dia de hoy es <strong>PubSub</strong>.</p>
<p>La libreria <strong>PubSub</strong> nos permite mediante el metodo <strong>publish</strong> publicar un evento, tal como se muetras a continuacion:</p>
<p><img src="./Images/0032.png" alt="Inicializadores de propiedades"></p>
<p>Por otro lado para escuchar el evento se debe utilizar el metodo <strong>suscribe</strong> es en componente que deseemos que escuche
dicho evento:</p>
<p><img src="./Images/0033.png" alt="Inicializadores de propiedades"></p>
<p>Es importar desuscribirse cuando el componenete sea destruido, utilizando el metodo <strong>unsuscribe</strong>.</p>
<h2 id="variables-globales">Variables globales</h2>
<p>Es posible utilizar comunicacion entre componenetes mediante contamienacion de variables globales.
esta practica es desaconsejada, pero puede servir para aplicaciones de prueba.</p>
<h2 id="comunicacion-con-api-context">Comunicacion con API Context</h2>
<p>El <strong>API Context</strong> es una <strong>API</strong> de <strong>REACT</strong> que permite la comunicacion de componentes, mediante un objeto,
el cual genera los componentes <strong>Provider</strong> el cual posee un atributo <strong>value</strong> que le envia al componente <strong>hijo</strong> que 
desee recibirlo, y otro componente <strong>Consumer</strong> el cual obtiene los datos.</p>
<p><strong>Consumer</strong> recibe por primer valor una funcion que optiene el atributo <strong>value</strong>.</p>
<h2 id="render-props">Render Props</h2>
<p>Permite pasar informacion de un componente <strong>Hijo</strong> a un componente <strong>Padre</strong>. Esta <strong>prop</strong> consiste en pasar una funcion <strong>render</strong> al hijo
el cual renderice de forma dinamica una serie de etiquetas, haciendo que los componenetes sean aun mas reutilizables, y no dependan tanto de la
forma en la que uno quiere renderizar. Esto es muy util cuando se trabaja en componentes que iteran sobre listas y sus funcionalidades, y su visualizacion son
parecidas.</p>
<p><img src="./Images/0034.png" alt="Inicializadores de propiedades"></p>
<h2 id="patrones-hoc-high-order-component-">Patrones HOC ( High Order Component )</h2>
<p>Permite la comunicacion bidirrecional, y es una funcion la cual retorna un nuevo componente.</p>
<p><img src="./Images/0035.png" alt="Inicializadores de propiedades"></p>
<p>Los <strong>HOC</strong> se suelen nombrar con <strong>with</strong> seguido por la accion que realizan, en la imagen anterior el nombre apropiado seria <strong>withAdd</strong>.</p>
<h3 id="pasar-configuraciones-a-un-hoc">Pasar configuraciones a un HOC</h3>
<p>Existen 2 formas de pasar configuraciones a un <strong>HOC</strong>, las cuales son</p>
<p>1- Mediante otro variable de entrada de la funcion <strong>HOC</strong>.
2- Mediante una doble execucion del la funcion <strong>HOC</strong>.</p>
<h1 id="10-hooks">10- Hooks</h1>
<p>Nos permiten implementar componentes basados en funciones y dotarlos de las propiedades que poseen las propiedades de los componentes basados en
clase.</p>
<h2 id="usestate">useState</h2>
<p>Este <strong>hook</strong> permite utilizar el <strong>state</strong> y actualizarlo, para ello se debe importar el metodo <strong>useState</strong> del modulo <strong>react</strong>.</p>
<p><img src="./Images/0036.png" alt="Inicializadores de propiedades"></p>
<p>Este <strong>hook</strong> permite que los <strong>estados</strong> sean cualquier tipo de variable desde booleanos hasta objetos, aunque el equipo de desarrollo de <strong>REACT</strong>,
no recomienda la implementacion de objetos, ya que para su actualizacion se necesita realizar un <strong>spread</strong> entre el estado anterior y el estado actual.</p>
<h2 id="useeffect">useEffect</h2>
<p>El <strong>hook</strong> <strong>useEffect</strong> viene a cumplir las funciones de los metodos de ciclo de vida como <strong>componentDidMount</strong>, <strong>componentDidUpdate</strong> y <strong>componentWillUnmount</strong>.</p>
<p>Para utilizar <strong>useEffect</strong> para suplir las funcionalidades de <strong>componentDidMount</strong> y <strong>componentDidUpdate</strong> se implementa una arrow function las cual ejecuta las
tareas necesarias. En cambio si se desea utilizar <strong>componentWillUnmount</strong> debemos implementarle un <strong>return</strong> a <strong>useEffect</strong> el cual tambien debe ser una arrow function.</p>
<p>Como segundo parametro <strong>useEffect</strong> recibe un array el cual le indica cuando ejecutarse, es decir, se ejecutara cuando las variables dentro de ese array presenten un cambio.</p>
<p><img src="./Images/0037.png" alt="Inicializadores de propiedades"></p>
<p>Si no le pasamos un array vacio se ejecutara una unica vez, en cambio si no le pasamos ningun valor se ejecutara siempre.</p>
<h2 id="reglas-de-hooks">Reglas de Hooks</h2>
<p>Los hooks se deben ejecutar en el 1er nivel del componente, no se deben implementar hooks en bucleas o condicionales, para implementar un hook personalizado
su nombre debe comenzar con <strong>use</strong> tal como lo hacen los hooks de <strong>REACT</strong>.</p>
<h2 id="uselayouteffect">useLayoutEffect</h2>
<p>Es un <strong>hook</strong> muy poco utilizado, ya que es practicamente igual que el <strong>useEffect</strong>, siempre se ejecutaran primero los <strong>useLayoutEffect</strong> antes que los <strong>useEffect</strong>, y se 
ejecuta antes de la actualizacion del <strong>DOM</strong>.</p>
<h2 id="usecontext">useContext</h2>
<p>Este <strong>hook</strong> suplanta el <strong>API Context</strong> visto en la seccion anterior. Para utilizar el <strong>useContext</strong> le debo pasar por parametro el contexto que queremos utilizar. </p>
<p><img src="./Images/0038.png" alt="Inicializadores de propiedades"></p>
<h2 id="useref">useRef</h2>
<p>Este <strong>hook</strong> permite utilizar referencias, dentro de los componenetes funcionales, suplantando al metodo <strong>createRef</strong>.</p>
<h2 id="hooks-de-terceros">Hooks de terceros</h2>
<p>Se pueden intstallar <strong>hooks</strong> de terceros con <strong>npm</strong>, como por ejemplo el hooks <strong>useDebounce</strong> el cual permite hacer peticiones cada un determinado tiempo.</p>
<h2 id="usereducer">useReducer</h2>
<p>Es una forma alternativa del <strong>hook</strong> <strong>useState</strong> y se suele utilizar cuando el estado posee muchas variables. Para la implementacion se debe pasar como primer parametro
una funcion que recibe el <strong>state</strong> y la <strong>action</strong>, y como segundo parametro el estado inicial.</p>
<p><img src="./Images/0039.png" alt="Inicializadores de propiedades"></p>
<p>Luego la funcion <strong>reducer</strong> se suele implementar de la forma:</p>
<p><img src="./Images/0040.png" alt="Inicializadores de propiedades"></p>
<h2 id="useimperativehandle">useImperativeHandle</h2>
<p>Este <strong>hook</strong> permite pasar la <strong>ref</strong> de un padre a un hijo, de primer valor recibe la referencia y como segundo parametro una arrow function, la cual retorna un objeto que estara disponible en el padre, utilizando la <strong>ref</strong>.</p>
<p><img src="./Images/0041.png" alt="Inicializadores de propiedades"></p>
<h2 id="react-memo-">React.memo()</h2>
<p>El metodo <strong>memo</strong> nos permite almacenar memoria y optimizar cuando la pagina web se actulizara, para ello debemos envolver a nuestro componente
evitando asi las renderizacion inecesarias.</p>
<p><img src="./Images/0042.png" alt="Inicializadores de propiedades"></p>
<p>Cabe aclarar que las comparaciones de las <strong>props</strong> son de 1er nivel, si existen objetos anidados esto causa error. Para dichos casos <strong>memo</strong> admite
como segundo parametro la funcion de diferenciacion, la cual debemos implementar nosotros. El componente re renderizara cuando la funcion de diferenciacion
retorne <strong>false</strong> en caso contrario no se renderizara.</p>
<h2 id="usecallback">useCallback</h2>
<p>Evite crear funciones con cada renderizado y se utiliza con <strong>memo</strong> y sirve para cuando el padre le pase al hijo un funcion. Cabe destacar que si se desea
actualizar un estado debemos utilizar la forma de arrow function para el
<strong>setState</strong>.</p>
<p><img src="./Images/0043.png" alt="Inicializadores de propiedades"></p>
<p>Al metodo <strong>useCallback</strong> se le pueden pasar dependencias para que la funcion se actualice cuando cambie algun valor.</p>
<p><img src="./Images/0044.png" alt="Inicializadores de propiedades"></p>
<h2 id="usememo">useMemo</h2>
<p>Nos permite memorizar, y no se renderiza a menos que cambie, como segundo parametro le podemos pasar una lista
de dependencias indicandole cuando queremos que se actualice.</p>
<h2 id="hooks-personalizados">Hooks personalizados</h2>
<p>Los <strong>hooks</strong> personalizados nos permiten reutilizar logica, como por ejemplo peticiones <strong>http</strong>. Para obtener valores de un <strong>hook</strong> estos deben
ser retornados.</p>
<p><img src="./Images/0045.png" alt="Inicializadores de propiedades"></p>
<h2 id="usedebugvalue">useDebugValue</h2>
<p>Este nos permite agregar etiquetas para las <strong>reactDevTools</strong> y poder identificarlo facilmente. Es recomendado utilizar esta herramienta cuando
creemos un <strong>hook</strong> para compartir con la comunidad</p>
<h2 id="eslint">eslint</h2>
<p>Un plugin muy util para el desarrollo con <strong>hooks</strong> en <strong>REACT</strong> es el eslint-plugin-react-hooks el cual nos ayuda a tener buenas
practicas de hooks.</p>
<blockquote>
<p>npm i -D eslint-plugin-react-hooks</p>
</blockquote>
<h1 id="11-props-children">11- Props Children</h1>
<p>El manejo del los <strong>children</strong> dependen unicamente del componente <strong>padre</strong>, los <strong>children</strong> pueden ser cualquier elemento
incluso arrow function, pero solo pueden ser renderizados <strong>textos</strong> o elementos de <strong>HTML</strong>. </p>
<p>Los <strong>children</strong> son una estructura de datos opacos, pues no sabemos que nos va a llegar, si un array, un objeto o texto plano.</p>
<h2 id="tratamiento-de-children">Tratamiento de Children</h2>
<p>Para el tratamiento de Children <strong>REACT</strong> proporciona diferentes metodos los cuales se encuentran en <strong>REACT.Children</strong>, estos metodos pueden ser:</p>
<p>1- <strong>map</strong>: itera solo sobre los hijos que puede renderizar y retorna un array.</p>
<p><img src="./Images/0046.png" alt="Inicializadores de propiedades"></p>
<p>2- <strong>forEach</strong>: itera sobre todos los hijos que puede renderizar y retorna un elemento.</p>
<p><img src="./Images/0047.png" alt="Inicializadores de propiedades"></p>
<p>3- <strong>toArray</strong>: convierte el <strong>children</strong> en un array, muy util cuando no sabemos cuando <strong>children</strong> vamos a recibir.</p>
<p>4- <strong>only</strong>: verifica que solo tengamos un <strong>children</strong>.</p>
<h2 id="composicion-implicita">Composicion implicita</h2>
<p>Para pasarle <strong>props</strong> a un componente que venga como <strong>children</strong> debemos utilizar el metodo <strong>cloneElement</strong> de <strong>REACT</strong>, el cual recibe como primer parametro
el elemento y como segundo parametro las props.</p>
<p><img src="./Images/0048.png" alt="Inicializadores de propiedades"></p>
<p>Puedo saber el type de un <strong>child</strong> y comprarlo directamente con el tipo de etiqueta que espero para saber que <strong>props</strong> pasarles.</p>
<p><img src="./Images/0049.png" alt="Inicializadores de propiedades"></p>
<h1 id="12-fundamentos-de-division-de-codigo-y-lazy-load">12- Fundamentos de division de codigo y lazy load</h1>
<p>En este apartado veremos formas de mejorar la eficiencia de nuestro codigo basados en 2 tecnicas el <strong>code Splitting</strong> y el <strong>lazy load</strong></p>
<h2 id="code-splitting">Code Splitting</h2>
<p>Este metodo es dividir nuetro codigo, haciendo mas sencilla la carga.</p>
<p>Para generar esta accion debemos utilizar <strong>lazy</strong>, la cual recibe una arrow function y debe retornar la importacion asincrona de nuestro componente.</p>
<p><img src="./Images/0050.png" alt="Inicializadores de propiedades"></p>
<h2 id="lazy-load">Lazy Load</h2>
<p>Este metodo consiste en descargar una fraccion de codigo, la cual necesita la aplicacion para arrancar
y luego ir descargando los fragmentos de codigo que sean necesarios para su funcionamiento.</p>
<p>Para el lazy load debemos utilizar el componente <strong>Suspense</strong> de <strong>REACT</strong>.</p>
<p><img src="./Images/0051.png" alt="Inicializadores de propiedades"></p>
<h1 id="13-animaciones-y-transiciones">13- Animaciones y transiciones</h1>
<h2 id="transition">Transition</h2>
<p>La propiedad <strong>transition</strong> recibe como parametros:</p>
<p>1- Los elementos a los cuales los afectara dicha propiedad.
2- El primer tiempo que se ingrese sera la duracion de la animacion
3- El segundo tiempo sera el delay o retraso de la animacion
4- Es el tipo de aceleracion de la animacion</p>
<p>Los elementos se pueden pasar por separado mediante los atributos:</p>
<p>a- <strong>transition-property</strong>
b- <strong>trnasition-duration</strong>
c- <strong>trnasition-delay</strong>
d- <strong>trnasition-timing-function</strong></p>
<h2 id="funciones-de-animacion">Funciones de animacion</h2>
<p>Es posible generar animaciones personalizadas, lo que nos permite mejorar la experiencia de usuario. Esto se hace 
utilizando la propiedad <strong>animation</strong> se pueden declarar animaciones personalizadas con
<strong>@keyframes</strong>.</p>
<p><img src="./Images/0052.png" alt="Inicializadores de propiedades"></p>
<p>Es posible no declarar el valor 50% utilizando la propiedad <strong>animation-direction</strong> la cual nos permite seleccionar cual es la
dirrecion de la animacion.</p>
<p><img src="./Images/0053.png" alt="Inicializadores de propiedades"></p>
<p>Mediante la propiedad <strong>animation-fill-mode</strong> puedo seleccionar las propiedades finales que tendra el objeto una vez acabada la 
animacion. Utilizando <strong>forwards</strong> para los valos finales y <strong>backwards</strong> para los iniciales.</p>
<p><img src="./Images/0054.png" alt="Inicializadores de propiedades"></p>

      </body>
    </html>